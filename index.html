<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rabbithole</title>
    
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a; /* Dark Earth */
            font-family: 'Courier Prime', monospace;
            color: #e5e5e5;
            overflow-x: hidden; 
            overflow-y: scroll; 
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: #0a0a0a; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 5px; }

        /* Animations */
        .node-enter {
            animation: digIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            opacity: 0;
            transform: translateY(-20px);
        }
        
        @keyframes digIn {
            to { opacity: 1; transform: translateY(0); }
        }
        
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        /* Texture Utilities */
        .bg-bedrock-fixed {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #0a0a0a;
            background-image: 
                radial-gradient(circle at 50% 50%, #111 1px, transparent 1px),
                radial-gradient(circle at 20% 20%, #151515 2px, transparent 2px);
            background-size: 40px 40px;
            z-index: -1;
            pointer-events: none;
        }

        .paper-shadow {
            box-shadow: 6px 6px 0px rgba(0, 0, 0, 0.5);
        }

        .camera-stage {
            transition: transform 0.1s linear;
            will-change: transform;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- Icons (Inlined) ---
        const Icon = ({ children, size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );

        const Icons = {
            Search: (props) => <Icon {...props}><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></Icon>,
            Settings: (props) => <Icon {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></Icon>,
            ExternalLink: (props) => <Icon {...props}><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></Icon>,
            ArrowDownCircle: (props) => <Icon {...props}><circle cx="12" cy="12" r="10"/><polyline points="8 12 12 16 16 12"/><line x1="12" y1="8" x2="12" y2="16"/></Icon>,
            Shuffle: (props) => <Icon {...props}><polyline points="16 3 21 3 21 8"/><line x1="4" y1="20" x2="21" y2="3"/><polyline points="21 16 21 21 16 21"/><line x1="15" y1="15" x2="21" y2="21"/><line x1="4" y1="4" x2="9" y2="9"/></Icon>,
            Layers: (props) => <Icon {...props}><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></Icon>,
            AlertCircle: (props) => <Icon {...props}><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></Icon>,
            RefreshCw: (props) => <Icon {...props}><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></Icon>
        };

        // --- Constants ---
        const BROAD_SUBJECTS = [
            "Philosophy", "Space", "Art history", "Quantum mechanics", "Time",
            "Consciousness", "Mathematics", "Anthropology", "Universe", "Mythology",
            "Artificial intelligence", "Linguistics", "Oceanography", "Architecture", "Psychology",
            "Renaissance", "Evolution", "Botany", "Cryptography", "Alchemy",
            "Surrealism", "Game theory", "Black hole", "Existentialism", "Cybernetics",
            "Ancient Egypt", "Neuroscience", "Music theory", "Political science", "Internet",
            "Chaos theory", "Metaphysics", "Ethics", "Logic", "Semiotics",
            "Film noir", "Industrial revolution", "Biomimicry", "Nanotechnology", "Dark matter",
            "Stoicism", "Epistemology", "Thermodynamics", "Literature", "Poetry",
            "Sociology", "Economics", "Geology", "Astronomy", "Theology",
            "History of science", "Cognitive science", "Entropy", "Paradox", "Infinity",
            "Complexity theory", "Urban planning", "Archaeology", "Cartography", "Genetics"
        ];

        // --- Utility: Wikipedia API ---
        const WIKI_API = "https://en.wikipedia.org/w/api.php";

        const searchWikiTitle = async (query) => {
            try {
                const params = new URLSearchParams({
                    action: "opensearch",
                    search: query,
                    limit: "1",
                    namespace: "0",
                    format: "json",
                    origin: "*"
                });
                const res = await fetch(`${WIKI_API}?${params}`);
                const data = await res.json();
                if (data[1] && data[1].length > 0) {
                    return data[1][0];
                }
                return null;
            } catch (e) {
                return null;
            }
        };

        const fetchWikiSummary = async (title) => {
            try {
                const params = new URLSearchParams({
                    action: "query",
                    format: "json",
                    prop: "extracts",
                    titles: title,
                    exintro: 1,
                    explaintext: 1,
                    origin: "*"
                });
                const res = await fetch(`${WIKI_API}?${params}`);
                const data = await res.json();
                const pageId = Object.keys(data.query.pages)[0];
                if (pageId === "-1") return "The rabbit hole ends here (Page not found).";
                return data.query.pages[pageId].extract;
            } catch (e) {
                return "Connection lost in the burrow.";
            }
        };

        const fetchWikiLinks = async (title) => {
            try {
                const params = new URLSearchParams({
                    action: "query",
                    format: "json",
                    prop: "links",
                    titles: title,
                    pllimit: "max",
                    plnamespace: 0,
                    origin: "*"
                });
                const res = await fetch(`${WIKI_API}?${params}`);
                const data = await res.json();
                const pageId = Object.keys(data.query.pages)[0];
                if (!data.query.pages[pageId].links) return [];
                return data.query.pages[pageId].links.map(l => l.title);
            } catch (e) {
                return [];
            }
        };

        // --- Component: Header ---
        const Header = () => {
            return (
                <div className="h-[33vh] w-full bg-[#f0f0f0] relative flex items-end justify-between px-8 md:px-24 border-b-4 border-black z-20">
                    <div className="relative w-32 h-32 md:w-48 md:h-48 transform translate-y-1 z-10">
                        <svg viewBox="0 0 200 200" className="w-full h-full drop-shadow-xl">
                            <path fill="#0a0a0a" d="M60,180 C60,180 40,170 40,140 C40,110 55,100 55,100 C55,100 45,60 50,30 C55,10 70,5 80,20 C85,5 100,10 105,40 C105,40 115,100 115,100 C115,100 130,105 140,120 C150,135 145,150 145,150 L160,160 L150,180 Z" />
                            <circle cx="135" cy="135" r="12" fill="#0a0a0a" stroke="#f0f0f0" strokeWidth="2" />
                            <line x1="135" y1="135" x2="135" y2="128" stroke="#f0f0f0" strokeWidth="2" />
                            <line x1="135" y1="135" x2="140" y2="135" stroke="#f0f0f0" strokeWidth="2" />
                        </svg>
                    </div>
                    <div className="mb-8 text-right z-0">
                        <h1 className="text-5xl md:text-7xl text-[#0a0a0a] font-bold tracking-tighter">RABBITHOLE</h1>
                        <p className="text-[#0a0a0a] opacity-60 text-sm italic mt-2">"Begin at the beginning..."</p>
                    </div>
                </div>
            );
        };

        // --- Component: Stealth Nav Bar ---
        const StealthNav = ({ holeCount, setHoleCount, chaos, setChaos, onSearch }) => {
            const [isHovered, setIsHovered] = useState(false);
            const [searchVal, setSearchVal] = useState("");
            const [error, setError] = useState(false);
            const [loading, setLoading] = useState(false);

            const handleSearch = async (e) => {
                e.preventDefault();
                if(searchVal.trim()) {
                    setLoading(true);
                    setError(false);
                    const result = await searchWikiTitle(searchVal);
                    setLoading(false);
                    if (result) {
                        onSearch(result);
                        setSearchVal("");
                        setIsHovered(false);
                    } else {
                        setError(true);
                        setTimeout(() => setError(false), 1000);
                    }
                }
            }

            return (
                <div 
                    className="fixed top-6 right-6 z-50 flex flex-col items-end"
                    onMouseEnter={() => setIsHovered(true)}
                    onMouseLeave={() => setIsHovered(false)}
                >
                    <div className={`
                        w-12 h-12 bg-white rounded-full flex items-center justify-center border-2 border-black shadow-lg cursor-pointer transition-all duration-300
                        ${isHovered ? 'scale-110 rotate-180' : 'scale-100'}
                    `}>
                        <Icons.Settings size={20} className="text-black" />
                    </div>

                    <div className={`
                        mt-4 bg-[#0a0a0a] border border-white p-4 shadow-2xl paper-shadow w-72 transition-all duration-300 origin-top-right
                        ${isHovered ? 'opacity-100 scale-100 translate-y-0' : 'opacity-0 scale-95 -translate-y-4 pointer-events-none'}
                    `}>
                        <form onSubmit={handleSearch} className={`mb-6 relative ${error ? 'shake' : ''}`}>
                            <input 
                                type="text" 
                                value={searchVal}
                                onChange={(e) => setSearchVal(e.target.value)}
                                placeholder={loading ? "LOCATING..." : (error ? "NO RESULTS" : "JUMP TO SUBJECT...")}
                                className={`w-full bg-black border p-2 pl-8 text-sm focus:outline-none font-mono text-white uppercase transition-colors
                                    ${error ? 'border-red-500 placeholder-red-500' : 'border-[#555] focus:border-white'}
                                `}
                            />
                            {error ? 
                                <Icons.AlertCircle className="absolute left-2 top-2.5 text-red-500" size={14} /> :
                                <Icons.Search className="absolute left-2 top-2.5 text-gray-500" size={14} />
                            }
                        </form>

                        <div className="space-y-6 text-white">
                            <div>
                                <div className="flex justify-between text-xs mb-2 text-gray-400 uppercase tracking-widest">
                                    <span className="flex items-center gap-2"><Icons.Layers size={12} /> Hole Count (n)</span>
                                    <span>{holeCount}</span>
                                </div>
                                <input 
                                    type="range" min="1" max="6" 
                                    value={holeCount} 
                                    onChange={(e) => setHoleCount(Number(e.target.value))}
                                    className="w-full accent-white bg-gray-800 h-1 appearance-none cursor-pointer" 
                                />
                            </div>

                            <div>
                                <div className="flex justify-between text-xs mb-2 text-gray-400 uppercase tracking-widest">
                                    <span className="flex items-center gap-2"><Icons.Shuffle size={12} /> Chaos Factor</span>
                                    <span>{chaos}%</span>
                                </div>
                                <input 
                                    type="range" min="0" max="100" step="10"
                                    value={chaos} 
                                    onChange={(e) => setChaos(Number(e.target.value))}
                                    className="w-full accent-white bg-gray-800 h-1 appearance-none cursor-pointer" 
                                />
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Component: The Node (Hole) ---
        const Node = ({ node, onExpand, onNavigate, onHoverChange, scale = 1 }) => {
            const [hovered, setHovered] = useState(false);
            const [summary, setSummary] = useState("Loading...");

            useEffect(() => {
                if (hovered && summary === "Loading...") {
                    fetchWikiSummary(node.title).then(txt => setSummary(txt.substring(0, 250) + "..."));
                }
            }, [hovered, node.title]);

            const handleMouseEnter = () => {
                setHovered(true);
                onHoverChange(node.id, true);
            };

            const handleMouseLeave = () => {
                setHovered(false);
                onHoverChange(node.id, false);
            };

            return (
                <div 
                    className="absolute transform -translate-x-1/2 node-enter"
                    style={{ 
                        left: node.x, 
                        top: node.y,
                        zIndex: hovered ? 50 : 10
                    }}
                    onMouseEnter={handleMouseEnter}
                    onMouseLeave={handleMouseLeave}
                >
                    <div 
                        className={`
                            bg-black border-2 border-white p-4 relative transition-all duration-300
                            ${hovered ? 'w-80 h-64 z-50 -translate-y-4 shadow-2xl scale-100' : 'w-48 h-24 flex items-center justify-center hover:scale-105'} // Changed min-h-64 to h-64 for fixed height
                        `}
                        style={{
                        transform: !hovered && scale < 1 ? `scale(${scale})` : undefined
                        }}
                    >
                        <h3 className={`text-center font-bold text-white ${hovered ? 'text-xl mb-4 border-b pb-2 border-gray-700' : 'text-sm line-clamp-2'}`}>
                            {node.title}
                        </h3>

                        {hovered && (
                            <div className="animate-fade-in">
                                <p className="text-xs text-gray-300 mb-4 leading-relaxed font-light font-sans">
                                    {summary}
                                </p>
                                <div className="flex gap-2 mt-auto absolute bottom-4 left-4 right-4">
                                    <button 
                                        onClick={(e) => { e.stopPropagation(); onExpand(node); }}
                                        className="flex-1 bg-white text-black py-2 text-xs font-bold hover:bg-gray-200 flex items-center justify-center gap-2 border border-white"
                                    >
                                        <Icons.ArrowDownCircle size={14} /> DIG
                                    </button>
                                    <button 
                                        onClick={(e) => { e.stopPropagation(); onNavigate(node.title); }}
                                        className="flex-1 border border-white text-white py-2 text-xs font-bold hover:bg-gray-900 flex items-center justify-center gap-2"
                                    >
                                        <Icons.ExternalLink size={14} /> VIEW
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- Component: Smart Connections ---
        const Connections = ({ nodes, dugIds, hoveredNodeId }) => {
        const NON_HOVERED_HEIGHT = 96; // Matches h-24 (6rem = 96px assuming 16px rem)
        const HOVERED_HEIGHT = 256; // Matches h-64 (16rem = 256px)
        const HOVER_LIFT = -16; // Matches -translate-y-4 ( -1rem = -16px)
    
        const paths = useMemo(() => {
            return nodes
                .filter(node => node.parentId)
                .map(childNode => {
                    const parent = nodes.find(p => p.id === childNode.parentId);
                    if (!parent) return null;
    
                    const isDug = dugIds.has(childNode.id);
                    const isParentHovered = hoveredNodeId === parent.id;
                    const isChildHovered = hoveredNodeId === childNode.id;
                    const isAnyHovered = isParentHovered || isChildHovered;
    
                    if (!isDug && !isAnyHovered) return null;
    
                    const parentHeight = isParentHovered ? HOVERED_HEIGHT : NON_HOVERED_HEIGHT;
                    const parentLift = isParentHovered ? HOVER_LIFT : 0;
                    const childLift = isChildHovered ? HOVER_LIFT : 0;
    
                    const startX = parent.x;
                    const startY = parent.y + parentLift + parentHeight;
                    const endX = childNode.x;
                    const endY = childNode.y + childLift;
    
                    return (
                        <line
                            key={`${parent.id}-${childNode.id}`}
                            x1={startX}
                            y1={startY}
                            x2={endX}
                            y2={endY}
                            stroke="white"
                            strokeWidth={isDug ? 3 : 2}
                            strokeDasharray={isDug ? "none" : "10,6"}
                            opacity={isDug ? 0.9 : 0.45}
                            className="transition-all duration-300 ease-out" // Smoother transition
                            pointerEvents="none"
                        />
                    );
                });
        }, [nodes, dugIds, hoveredNodeId]);
    
        return (
            <svg
                className="absolute inset-0 w-full h-full pointer-events-none overflow-visible"
                style={{ zIndex: 5 }}
            >
                {paths}
            </svg>
        );
    };

        // --- Component: Refresh Button ---
        const RefreshLayerBtn = ({ onClick, yPos, xPos, isRoot = false }) => (
            <div 
                className="absolute transform -translate-x-1/2 z-40 group"
                style={{ 
                    top: yPos, 
                    left: xPos !== undefined ? xPos : '50%' 
                }}
            >
                <button 
                    onClick={onClick}
                    className="bg-[#0a0a0a] border border-[#333] text-gray-500 hover:text-white hover:border-white px-6 py-2 rounded-full flex items-center gap-2 text-xs tracking-wide transition-all shadow-lg"
                >
                    <Icons.RefreshCw size={12} className="group-hover:animate-spin" />
                    {isRoot ? "REFRESH SURFACE" : "REFRESH LAYER"}
                </button>
            </div>
        );

        // --- Main App Logic ---
        const App = () => {
            const [nodes, setNodes] = useState([]);
            const [maxHeight, setMaxHeight] = useState(1000);
            const [holeCount, setHoleCount] = useState(3);
            const [chaos, setChaos] = useState(20); 
            const [cameraX, setCameraX] = useState(0);

            const [activeParentId, setActiveParentId] = useState(null);
            const activeLinksCache = useRef([]);
            
            const [dugIds, setDugIds] = useState(new Set()); 
            const [hoveredNodeId, setHoveredNodeId] = useState(null);

            const getRandomSubjects = (count) => {
                const shuffled = [...BROAD_SUBJECTS].sort(() => 0.5 - Math.random());
                return shuffled.slice(0, count);
            };

            // --- METRICS (Center Calculation) ---
            // 1. For Deep Layers
            const activeLayerMetrics = useMemo(() => {
                if (!activeParentId) return null;
                const children = nodes.filter(n => n.parentId === activeParentId);
                
                if (children.length === 0) return null;
                
                // Bounding Box Center
                const minX = Math.min(...children.map(n => n.x));
                const maxX = Math.max(...children.map(n => n.x));
                const centerX = (minX + maxX) / 2;
                const y = children[0].y; 
                
                return { x: centerX, y };
            }, [nodes, activeParentId]);

            // 2. For Root Layer
            const rootLayerCenter = useMemo(() => {
                const roots = nodes.filter(n => n.depth === 0);
                if (roots.length === 0) return window.innerWidth / 2;
                
                const minX = Math.min(...roots.map(n => n.x));
                const maxX = Math.max(...roots.map(n => n.x));
                return (minX + maxX) / 2;
            }, [nodes]);


            // --- CAMERA LOGIC ---
            const activePath = useMemo(() => {
                if (!activeParentId) return [];
                const path = [];
                let currentId = activeParentId;
                while(currentId) {
                    const node = nodes.find(n => n.id === currentId);
                    if(node) {
                        path.unshift(node);
                        currentId = node.parentId;
                    } else {
                        break;
                    }
                }
                return path;
            }, [activeParentId, nodes]);

            useEffect(() => {
                const handleScroll = () => {
                    const viewportCenterY = window.scrollY + (window.innerHeight / 2);
                    
                    if (activePath.length === 0) {
                        setCameraX(0);
                        return;
                    }

                    let targetX = 0;
                    const firstNode = activePath[0];
                    const lastNode = activePath[activePath.length - 1];
                    
                    if (viewportCenterY < firstNode.y) {
                        targetX = firstNode.x; 
                    } else if (viewportCenterY > lastNode.y + 96) {
                         targetX = lastNode.x;
                    } else {
                        let foundSegment = false;
                        for (let i = 0; i < activePath.length - 1; i++) {
                            const n1 = activePath[i];
                            const n2 = activePath[i+1];
                            const n1Bottom = n1.y + 96;
                            
                            if (viewportCenterY >= n1.y && viewportCenterY <= n1Bottom) {
                                targetX = n1.x;
                                foundSegment = true;
                                break;
                            } else if (viewportCenterY > n1Bottom && viewportCenterY < n2.y) {
                                const progress = (viewportCenterY - n1Bottom) / (n2.y - n1Bottom);
                                targetX = n1.x + (n2.x - n1.x) * progress;
                                foundSegment = true;
                                break;
                            }
                        }
                        if (!foundSegment) {
                            targetX = lastNode.x;
                        }
                    }
                    
                    const screenCenter = window.innerWidth / 2;
                    setCameraX(screenCenter - targetX);
                };

                window.addEventListener('scroll', handleScroll);
                return () => window.removeEventListener('scroll', handleScroll);
            }, [activePath]);


            const initializeBurrow = (startSubject = null) => {
                const initialSubjects = startSubject ? [startSubject] : getRandomSubjects(3);
                
                const screenWidth = window.innerWidth;
                const spacing = Math.min(250, (screenWidth * 0.9) / initialSubjects.length);
                const startXOffset = (screenWidth - ((initialSubjects.length - 1) * spacing)) / 2;

                const newNodes = initialSubjects.map((title, i) => ({
                    id: `root-${Date.now()}-${i}`,
                    title,
                    x: startSubject ? screenWidth / 2 : startXOffset + (i * spacing), 
                    y: 150,
                    parentId: null,
                    depth: 0
                }));
                
                setNodes(newNodes);
                setActiveParentId(null);
                setDugIds(new Set());
                activeLinksCache.current = [];
                setMaxHeight(1200);
                setCameraX(0); // Reset camera
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };

            useEffect(() => {
                initializeBurrow();
            }, []);

            const generateChildren = (parent, allLinks, count, chaosVal) => {
                let selectedLinks = [];
                const cleanLinks = allLinks.filter(t => !t.startsWith("List of") && !t.startsWith("Category:") && !t.includes(":"));
                
                if (chaosVal < 30) {
                    selectedLinks = cleanLinks.slice(0, count);
                } else if (chaosVal > 70) {
                    const shuffled = [...cleanLinks].sort(() => 0.5 - Math.random());
                    selectedLinks = shuffled.slice(0, count);
                } else {
                    const split = Math.floor(count / 2);
                    const relevant = cleanLinks.slice(0, split);
                    const random = [...cleanLinks].slice(split).sort(() => 0.5 - Math.random()).slice(0, count - split);
                    selectedLinks = [...relevant, ...random];
                }
        
                const screenWidth = window.innerWidth;
                const maxSpread = Math.min(280, screenWidth / (count + 1)); // Responsive: tighter on small screens
                const totalWidth = (selectedLinks.length - 1) * maxSpread;
                const startX = parent.x - (totalWidth / 2);
                const childY = parent.y + 400; // Increased from 350 for more breathing room
        
                return selectedLinks.map((title, i) => ({
                    id: `${parent.id}-child-${i}-${title.replace(/\s/g,'')}`,
                    title,
                    x: startX + (i * maxSpread) + (Math.random() - 0.5) * 20 * (chaosVal / 100), // Slight random jiggle for chaos
                    y: childY,
                    parentId: parent.id,
                    depth: parent.depth + 1,
                    scale: 1 
                }));
            };

            const addNodes = async (parentNode) => {
                let trace = parentNode;
                const newDug = new Set();
                while(trace) {
                    newDug.add(trace.id);
                    trace = nodes.find(n => n.id === trace.parentId);
                }
                setDugIds(newDug);

                setNodes(prev => prev.filter(n => n.depth <= parentNode.depth));

                const links = await fetchWikiLinks(parentNode.title);
                if (links.length === 0) return;

                setActiveParentId(parentNode.id);
                activeLinksCache.current = links;

                const newChildren = generateChildren(parentNode, links, holeCount, chaos);

                setNodes(prev => {
                    const pruned = prev.filter(n => n.depth <= parentNode.depth);
                    return [...pruned, ...newChildren];
                });
                
                const childY = parentNode.y + 350;
                if (childY + 400 > maxHeight) {
                    setMaxHeight(childY + 600);
                }

                setTimeout(() => {
                    window.scrollTo({ top: childY - window.innerHeight / 2, behavior: 'smooth' });
                }, 100);
            };

            useEffect(() => {
                if (!activeParentId) return;

                const parentNode = nodes.find(n => n.id === activeParentId);
                if (!parentNode) return;

                const updatedChildren = generateChildren(parentNode, activeLinksCache.current, holeCount, chaos);

                setNodes(prev => {
                    const others = prev.filter(n => n.parentId !== activeParentId);
                    return [...others, ...updatedChildren];
                });

            }, [holeCount, chaos, activeParentId]);

            const handleRefreshLayer = () => {
                if (!activeParentId) return;
                
                const parentNode = nodes.find(n => n.id === activeParentId);
                if (!parentNode) return;

                if (chaos > 0) {
                    const updatedChildren = generateChildren(parentNode, activeLinksCache.current, holeCount, chaos);
                    setNodes(prev => [...prev.filter(n => n.parentId !== activeParentId), ...updatedChildren]);
                } else {
                    activeLinksCache.current = [...activeLinksCache.current.slice(1), activeLinksCache.current[0]];
                    const updatedChildren = generateChildren(parentNode, activeLinksCache.current, holeCount, chaos);
                    setNodes(prev => [...prev.filter(n => n.parentId !== activeParentId), ...updatedChildren]);
                }
            };

            const handleNavigate = (title) => {
                window.open(`https://en.wikipedia.org/wiki/${title}`, '_blank');
            };
            
            const handleHoverChange = (nodeId, isHovered) => {
                setHoveredNodeId(isHovered ? nodeId : null);
            };

            return (
                <>
                    <div className="bg-bedrock-fixed"></div>
                    
                    <StealthNav 
                        holeCount={holeCount} setHoleCount={setHoleCount}
                        chaos={chaos} setChaos={setChaos}
                        onSearch={(q) => initializeBurrow(q)}
                    />

                    {/* Main Camera Stage - Moves based on scroll */}
                    <div 
                        className="min-h-screen w-full relative flex flex-col camera-stage" 
                        style={{ height: maxHeight, transform: `translateX(${cameraX}px)` }}
                    >
                        <Header />

                        <div className="flex-grow relative w-full">
                            <RefreshLayerBtn 
                                onClick={() => initializeBurrow()} 
                                yPos={70} 
                                xPos={rootLayerCenter}
                                isRoot={true}
                            />

                            <Connections nodes={nodes} dugIds={dugIds} hoveredNodeId={hoveredNodeId} />

                            {nodes.map(node => (
                                <Node 
                                    key={node.id} 
                                    node={node} 
                                    onExpand={addNodes} 
                                    onNavigate={handleNavigate}
                                    onHoverChange={handleHoverChange}
                                    scale={node.scale}
                                />
                            ))}

                            {activeParentId && activeLayerMetrics && (
                                <RefreshLayerBtn 
                                    onClick={handleRefreshLayer} 
                                    yPos={activeLayerMetrics.y + 120} 
                                    xPos={activeLayerMetrics.x}
                                />
                            )}
                        </div>
                    </div>
                    
                    <div className="fixed bottom-4 left-0 w-full text-center text-xs text-gray-600 pointer-events-none z-50">
                        CURRENT DEPTH: {Math.floor(maxHeight / 100)}m
                    </div>
                </>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
